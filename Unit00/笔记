###第四章
1. 字符串常量用双引号，字符常量用单引号
2. 字符串可以使用双引号拼接
3. new和delete要配对使用，防止内存泄漏，delete只能释放用new分配的内存
4. 使用new和delete要遵守以下规则：  
    1. 不适用delete来释放不是new分配的内存
    2. 不使用delete来释放同一个内存卡2次
    3. 如果使用new[] 分配数组内存，应该使用delete[]释放
    4. 如果使用newp[]为一个实体分配内存，则应该使用delete释放
    5. 对空指针使用delete是安全的
    
5. 在C和C++中数组和指针基本等价
6. 在访问结构时，结构指针使用->操作符，结构对象使用.操作符
   
### 第7讲
1. 原型描述了函数到编译器的接口
2. C++的编程风格是将main放在最前面，因为它通常提供了程序的整体结构，这里有别与python的顺序解释
3. 函数原型不要求提供变量名
4. 当指针指向一个数组时，函数参数建议使用int a[], 当指向一个独立的值时，建议使用int* a
5. const int* pt,即pt指向一个const int 类型，但该常量只是针对pt来说是const的
6. 可以将const类型的常量赋值给const类型的指针，但不可以将const类型的地址给常规指针
7. 仅当只有一层间接关系时，才可以将非const地址赋值给const指针
8. **应当尽可能的使用const**
   1. 这样可以便面无意间修改数据而导致的编程错误
   2. 使用const使得函数能够处理const和非const实参，否接只能接受非const数据
   3. 如果条件允许，则应将指针声明为指向const的指针
   
9. int* const finger 声明一个常量类型的指针，该指针不可以被重新赋值
10. int (*arr)[4] 和 int arr[][4]相同，arr都指向一个由4个int为元素的数组的数组
11. 与数组名是数组地址不同，结构名只是结构的名称
12. 函数指针 double (*pf)(int), pf 即为函数指针

### 第8讲
1. 内联函数不执行程序地址跳转，而是在编译的时候就执行函数代码复制
2. int & rodents 是声明一个引用变量，作用上相当于一个变量的别名
3. 引用变量必须在声明时进行初始化
4. 引用变量通常作为函数参数，称为按引用传递
5. 如果不想让引用修改值的话可以再声明时加上const关键字
6. 引用非常适合结构和类，引入引用主要是为了用于这些类型
7. 通常将返回的引用声明为const，
8. 返回函数应当尽量避免当函数终止时不再存在的内存单元的引用
9. 基类引用可以指向派生类对象
10. 要为某个参数设置默认值，则必须为它右边的所有参数都提供默认值
11. 编译器在检查函数特征标时，将类型引用和类型本身视为同一个特征标
12. 匹配函数时并不区分const和非const
13. 仅当函数基本上执行相同的任务，但是使用不同形式的数据时，才应使用函数重载
14. C++可以使用template <class 类型名>或者template <typename 类型名> 来声明函数模板，即可以声明一个通用类型。这样编译器在进行编译时会自动将通用类型转换为参数类型
15. 如果需要多个将同一种算法用于不同类型的函数，请使用模板
16. 模板也可以进行重载。在每个重载的函数及原型前，都需要添加template <typename 类型名>来告诉编译器该函数需要使用模板替换
17. 显式具体化函数的原型和定义应以template<>打头，并且通过名称来指出具体类型 template<> void Swap<job>(job&, job&); <job>可选


