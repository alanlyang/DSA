###第四章
1. 字符串常量用双引号，字符常量用单引号
2. 字符串可以使用双引号拼接
3. new和delete要配对使用，防止内存泄漏，delete只能释放用new分配的内存
4. 使用new和delete要遵守以下规则：  
    1. 不适用delete来释放不是new分配的内存
    2. 不使用delete来释放同一个内存卡2次
    3. 如果使用new[] 分配数组内存，应该使用delete[]释放
    4. 如果使用newp[]为一个实体分配内存，则应该使用delete释放
    5. 对空指针使用delete是安全的
    
5. 在C和C++中数组和指针基本等价
6. 在访问结构时，结构指针使用->操作符，结构对象使用.操作符
   
### 第7讲
1. 原型描述了函数到编译器的接口
2. C++的编程风格是将main放在最前面，因为它通常提供了程序的整体结构，这里有别与python的顺序解释
3. 函数原型不要求提供变量名
4. 当指针指向一个数组时，函数参数建议使用int a[], 当指向一个独立的值时，建议使用int* a
5. const int* pt,即pt指向一个const int 类型，但该常量只是针对pt来说是const的
6. 可以将const类型的常量赋值给const类型的指针，但不可以将const类型的地址给常规指针
7. 仅当只有一层间接关系时，才可以将非const地址赋值给const指针
8. **应当尽可能的使用const**
   1. 这样可以便面无意间修改数据而导致的编程错误
   2. 使用const使得函数能够处理const和非const实参，否接只能接受非const数据
   3. 如果条件允许，则应将指针声明为指向const的指针
   
9. int* const finger 声明一个常量类型的指针，该指针不可以被重新赋值
10. int (*arr)[4] 和 int arr[][4]相同，arr都指向一个由4个int为元素的数组的数组
11. 与数组名是数组地址不同，结构名只是结构的名称
12. 函数指针 double (*pf)(int), pf 即为函数指针

### 第8讲
1. 内联函数不执行程序地址跳转，而是在编译的时候就执行函数代码复制
2. int & rodents 是声明一个引用变量，作用上相当于一个变量的别名
3. 引用变量必须在声明时进行初始化
4. 引用变量通常作为函数参数，称为按引用传递
5. 如果不想让引用修改值的话可以再声明时加上const关键字
6. 引用非常适合结构和类，引入引用主要是为了用于这些类型
7. 通常将返回的引用声明为const，
8. 返回函数应当尽量避免当函数终止时不再存在的内存单元的引用
9. 基类引用可以指向派生类对象
10. 要为某个参数设置默认值，则必须为它右边的所有参数都提供默认值
11. 编译器在检查函数特征标时，将类型引用和类型本身视为同一个特征标
12. 匹配函数时并不区分const和非const
13. 仅当函数基本上执行相同的任务，但是使用不同形式的数据时，才应使用函数重载
14. C++可以使用template <class 类型名>或者template <typename 类型名> 来声明函数模板，即可以声明一个通用类型。这样编译器在进行编译时会自动将通用类型转换为参数类型
15. 如果需要多个将同一种算法用于不同类型的函数，请使用模板
16. 模板也可以进行重载。在每个重载的函数及原型前，都需要添加template <typename 类型名>来告诉编译器该函数需要使用模板替换
17. 显式具体化函数的原型和定义应以template<>打头，并且通过名称来指出具体类型 template<> void Swap<job>(job&, job&); <job>可选

### 第9讲 
1. 通常不应将函数的定义或变量的生命放到头文件中
2. 头文件中通常包含的内容如下：
   1. 函数原型
   2. 使用#define 或 const 定义的符号常量
   3. 结构声明
   4. 类声明
   5. 模板声明
   6. 内联函数
   
3. include 使用<> 时 将在标准库中寻找，使用 "" 将在当前工作目录或者源代码目录中寻找
4. 可以使用auto来显式的指出存储类别，但只能用于默认状态下为自动的变量，因此几乎不使用
5. register 声明的变量提醒编译器，用户希望她能通过CPU的寄存器而不是堆栈来处理特定的变量，从而对变量进行快速访问， 如register int a;
6. 如果变量存在寄存器中，则没有内存地址，因此不能将地址操作符用于寄存器变量，（操作系统的原因）
7. 在默认情况下，静态数组和结构将每个元素或成员的所有位都设置位0
8. :: 为 C++提供的作用于解析符
9. 全局变量尤其适合标识常量数据，这样可以使用Const来防止数据被篡改。
10. 对于外部连接性变量，有且只有一个文件中包含了该变量的外部定义，其他文件要使用该变量，必须使用extern关键字
11. 应使用外部变量在多文件程序的不同部分之间共享数据，应使用链接性为背部的静态变量在同一个文件的多个函数间传递变量
12. static和const修饰的变量都不能被修改,C++指出，使用static来创建内部链接性的方法将逐步被淘汰
13. static声明的全局变量具有内部链接性，在声明后即便函数处于不活跃状态，其仍然在内存中存在
14. volatile关键字的作用是为了改善编译器的优化能力
15. mutable 指定结构的成员可被修改，尤其是结构类型声明为const时，可以指定某个成员为mutable
16. const声明全局变量时和 static 声明相同，都只有内部链接性， 要想具有外部链接性，需要在Const前加上extern关键字
17. 内部链接性意味着每个文件都有自己的一组常量，而不是所有文件共享一组常量
18. 通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储
19. 通常new 负责在堆heap中找到一个足以内能够满足要求的内存块。new操作符还有一种变体，被称为布局new操作符，能够让程序员指定要使用的位置
20. 要使用new布局特性，要在头文件中增加 #include <new>
21. 名称空间可以是全局的，也可以位于另一个名称空间中，但是不能位于代码块中。默认情况下，在名称空间中声明的名称的链接性是外部的
22. using 声明讲特定的名称添加到底它所属的声明区域中，如using Jill::fetch
23. 可以使用 namespace myth = my_favorite 来将my_favorite命名空间设置别名
24. C++标准不赞成在名称空间和全局作用域中使用static 如static int counts 可以改成 namesapce{ int counts }
26. 使用在已命名空间中声明的变量，而不是使用外部全局变量或静态全局变量
27. 如果开发了一个函数库或类库，将其放在一个名称空间中。名称空间的主旨是简化大型编程项目的管理工作。

