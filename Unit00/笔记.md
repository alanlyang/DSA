###第四章
1. 字符串常量用双引号，字符常量用单引号
2. 字符串可以使用双引号拼接
3. new和delete要配对使用，防止内存泄漏，delete只能释放用new分配的内存
4. 使用new和delete要遵守以下规则：  
    1. 不适用delete来释放不是new分配的内存
    2. 不使用delete来释放同一个内存卡2次
    3. 如果使用new[] 分配数组内存，应该使用delete[]释放
    4. 如果使用newp[]为一个实体分配内存，则应该使用delete释放
    5. 对空指针使用delete是安全的
    
5. 在C和C++中数组和指针基本等价
6. 在访问结构时，结构指针使用->操作符，结构对象使用.操作符
   
### 第7讲
1. 原型描述了函数到编译器的接口
2. C++的编程风格是将main放在最前面，因为它通常提供了程序的整体结构，这里有别与python的顺序解释
3. 函数原型不要求提供变量名
4. 当指针指向一个数组时，函数参数建议使用int a[], 当指向一个独立的值时，建议使用int* a
5. const int* pt,即pt指向一个const int 类型，但该常量只是针对pt来说是const的
6. 可以将const类型的常量赋值给const类型的指针，但不可以将const类型的地址给常规指针
7. 仅当只有一层间接关系时，才可以将非const地址赋值给const指针
8. **应当尽可能的使用const**
   1. 这样可以便面无意间修改数据而导致的编程错误
   2. 使用const使得函数能够处理const和非const实参，否接只能接受非const数据
   3. 如果条件允许，则应将指针声明为指向const的指针
   
9. int* const finger 声明一个常量类型的指针，该指针不可以被重新赋值
10. int (*arr)[4] 和 int arr[][4]相同，arr都指向一个由4个int为元素的数组的数组
11. 与数组名是数组地址不同，结构名只是结构的名称
12. 函数指针 double (*pf)(int), pf 即为函数指针

### 第8讲
1. 内联函数不执行程序地址跳转，而是在编译的时候就执行函数代码复制
2. int & rodents 是声明一个引用变量，作用上相当于一个变量的别名
3. 引用变量必须在声明时进行初始化
4. 引用变量通常作为函数参数，称为按引用传递
5. 如果不想让引用修改值的话可以再声明时加上const关键字
6. 引用非常适合结构和类，引入引用主要是为了用于这些类型
7. 通常将返回的引用声明为const，
8. 返回函数应当尽量避免当函数终止时不再存在的内存单元的引用
9. 基类引用可以指向派生类对象
10. 要为某个参数设置默认值，则必须为它右边的所有参数都提供默认值
11. 编译器在检查函数特征标时，将类型引用和类型本身视为同一个特征标
12. 匹配函数时并不区分const和非const
13. 仅当函数基本上执行相同的任务，但是使用不同形式的数据时，才应使用函数重载
14. C++可以使用template <class 类型名>或者template <typename 类型名> 来声明函数模板，即可以声明一个通用类型。这样编译器在进行编译时会自动将通用类型转换为参数类型
15. 如果需要多个将同一种算法用于不同类型的函数，请使用模板
16. 模板也可以进行重载。在每个重载的函数及原型前，都需要添加template <typename 类型名>来告诉编译器该函数需要使用模板替换
17. 显式具体化函数的原型和定义应以template<>打头，并且通过名称来指出具体类型 template<> void Swap<job>(job&, job&); <job>可选

### 第9讲 
1. 通常不应将函数的定义或变量的生命放到头文件中
2. 头文件中通常包含的内容如下：
   1. 函数原型
   2. 使用#define 或 const 定义的符号常量
   3. 结构声明
   4. 类声明
   5. 模板声明
   6. 内联函数
   
3. include 使用<> 时 将在标准库中寻找，使用 "" 将在当前工作目录或者源代码目录中寻找
4. 可以使用auto来显式的指出存储类别，但只能用于默认状态下为自动的变量，因此几乎不使用
5. register 声明的变量提醒编译器，用户希望她能通过CPU的寄存器而不是堆栈来处理特定的变量，从而对变量进行快速访问， 如register int a;
6. 如果变量存在寄存器中，则没有内存地址，因此不能将地址操作符用于寄存器变量，（操作系统的原因）
7. 在默认情况下，静态数组和结构将每个元素或成员的所有位都设置位0
8. :: 为 C++提供的作用于解析符
9. 全局变量尤其适合标识常量数据，这样可以使用Const来防止数据被篡改。
10. 对于外部连接性变量，有且只有一个文件中包含了该变量的外部定义，其他文件要使用该变量，必须使用extern关键字
11. 应使用外部变量在多文件程序的不同部分之间共享数据，应使用链接性为背部的静态变量在同一个文件的多个函数间传递变量
12. static和const修饰的变量都不能被修改,C++指出，使用static来创建内部链接性的方法将逐步被淘汰
13. static声明的全局变量具有内部链接性，在声明后即便函数处于不活跃状态，其仍然在内存中存在
14. volatile关键字的作用是为了改善编译器的优化能力
15. mutable 指定结构的成员可被修改，尤其是结构类型声明为const时，可以指定某个成员为mutable
16. const声明全局变量时和 static 声明相同，都只有内部链接性， 要想具有外部链接性，需要在Const前加上extern关键字
17. 内部链接性意味着每个文件都有自己的一组常量，而不是所有文件共享一组常量
18. 通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储
19. 通常new 负责在堆heap中找到一个足以内能够满足要求的内存块。new操作符还有一种变体，被称为布局new操作符，能够让程序员指定要使用的位置
20. 要使用new布局特性，要在头文件中增加 #include <new>
21. 名称空间可以是全局的，也可以位于另一个名称空间中，但是不能位于代码块中。默认情况下，在名称空间中声明的名称的链接性是外部的
22. using 声明讲特定的名称添加到底它所属的声明区域中，如using Jill::fetch
23. 可以使用 namespace myth = my_favorite 来将my_favorite命名空间设置别名
24. C++标准不赞成在名称空间和全局作用域中使用static 如static int counts 可以改成 namesapce{ int counts }
26. 使用在已命名空间中声明的变量，而不是使用外部全局变量或静态全局变量
27. 如果开发了一个函数库或类库，将其放在一个名称空间中。名称空间的主旨是简化大型编程项目的管理工作。

### 第10讲 对象和类
1. 采用oop方法是，首先从用户的角度考虑对象-> 描述对象所需的数据以及描述用户与数据交互所需的操作；完成对接口的描述后，需要确定如何实现接口和数据存储。
2. 类贵方由两个部分组成，类声明和类方法定义
3. 类设计尽可能讲公有接口与实现细节分开，公有接口表示设计的抽象组件，讲实现细节放在一起并将他们与抽象分开被称为封装
4. 隐藏数据时oop的主要目标之一，因此数据项通常放在私有部分，组成类接口的成员函数一般放在公有部分
5. 通常使用私有成员函数来处理不属于公有接口的实现细节
6. 类对象的默认访问权限是private
7. 类与结构的区别在于，类的默认权限是private ,结构的默认权限是public
8. 类方法可以访问类的私有成员患
9. 类声明通常讲较为短小的成员函数作为内联函数。内联是代码的复制，而非寻址方式
10. 内联函数通常放于定义类的头文件中
11. 类的构造函数没有声明类型
12. 通常对类的数据成员增加m_前缀
13. 当且仅当类没有提供自定义的构造函数时，编译器才会提供默认的构造函数，如Stock(){};
14. 在设计类的时候，通常应提供对所有类成员做隐式初始化的默认函数，一般通过重载构造函数完成
15. 对象生命周期结束时调用析构函数。析构函数完成清理工作。
16. 析构函数的名称为类名前增加 ~ ，如 ~Stock(){}; 通常不应在代码中显式的调用析构函数，而应该交给编译器去完成
17. 析构函数在类对象过期时将被自动调用，因此析构函数是必须的，如果没有提供析构函数，编译器将隐式的声明一个默认的析构函数
18. 只要类方法不修改调用对象，就应该将其声明为const， 如 void Stock::show()const , const 要放在函数后面
19. this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法），注意this是一个地址，返回调用对象应该是 *this
20. 在类中声明枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称；其次可以使用static声明类全局变量，因为static变量时放在堆中的

### 第11讲 类的使用
1. 操作符重载需要使用特殊的函数形式： operator op(argument_list) op为要重载的操作符
2. 重载的操作符不必是成员函数，但是必须至少有一个操作数是用户定义的类型
3. 不能定义新的操作符，不能重载sizeof, ., .*. ::, ?: const_cast等操作符
4.  = , (), [], -> 只能通过成员函数进行重载 
5. C++控制对类对象私有部分的访问，通常，公有类方法是唯一的访问途径，但是友元除外
6. 友元包括 友元函数、友元类和友元成员函数，可以通过让函数成为类的友元，赋予该函数与类的成员函数相同的访问权限
7. 在为类重载二元操作符的时候通常需要友元
8. 友元函数的声明如下： friend Time operator* () 友元函数的实现不需要使用类限定符
9. 只有类声明可以决定哪一个函数是友元，即友元函数的声明必须在类中定义。类方法和友元只是表达类接口的两种不同机制
10. 在C++中，接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。
11. 只有接受一个参数的狗脏函数才能作为转换函数。如Stonewt myCat; myCat = 10.1;
12. 可以使用explicit关键字来关闭构造函数的隐式转换，如 explicit Stonewt(double lbs);
    但仍然可以使用显式转化，如 myCat = Stonewt(19.6);
13. 可以使用operator type_name() 的方式来声明转换函数. 例如 operator double()
    1. 转换函数必须是类方法
    2. 转换函数不能指定返回类型
    3. 转换函数不能有参数
    
14. 应该谨慎的使用隐式转换函数，通常，最好选择仅在被显式的调用时才会执行的函数

### 第12讲 类和动态内存分配

